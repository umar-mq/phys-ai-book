import Personalization from '@site/src/components/Personalization';
import Quiz from '@site/src/components/Quiz';

# 1.3 The Nervous System: Topics & Messages

<Personalization level="novice" language="english">

## How Robots Communicate: The Publisher-Subscriber Model

**The Broadcast Analogy**

In the previous section, we created **Nodes**. But a brain node is useless if it cannot tell the hand node to move. They need to talk.
In ROS 2, the primary way they talk is through **Topics**.

Think of a Topic like a **Radio Station** or a **YouTube Channel**.
*   **The Publisher**: This is the DJ or the YouTuber. They broadcast information out into the world. They don't know *who* is listening, they just talk.
*   **The Subscriber**: This is the listener. They tune into the specific channel (Topic) to get information.
*   **The Topic**: The specific channel name (e.g., `/robot/camera/image`).

**Why this way?**
Imagine if the Camera Node had to know the phone number of every other node to send an image. If you added a new screen to the robot, you would have to rewrite the Camera code. With Topics, the Camera just "publishes" the image. If 1 person listens, or 100 people listen, the Camera doesn't care. This makes the system flexible.

### Practical Exercise: The Chatty Robot

We will create two nodes. One will count numbers (Publisher), and the other will print them (Subscriber).

#### Step 1: The Publisher Node
Create a file `publisher_node.py` in your package.

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String  # We need a message type

class RobotNewsStation(Node):
    def __init__(self):
        super().__init__("robot_news_station")
        
        # Create a publisher
        # Topic name: "robot_news"
        # Message Type: String
        # Queue Size: 10
        self.publisher_ = self.create_publisher(String, "robot_news", 10)
        
        self.timer_ = self.create_timer(0.5, self.publish_news)
        self.get_logger().info("Robot News Station is live!")

    def publish_news(self):
        msg = String()
        msg.data = "Hello! The robot is operating normally."
        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = RobotNewsStation()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Step 2: The Subscriber Node
Create a file `subscriber_node.py`.

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SmartphoneNode(Node):
    def __init__(self):
        super().__init__("smartphone")
        
        # Create a subscriber
        # Topic name must match EXACTLY: "robot_news"
        self.subscriber_ = self.create_subscription(
            String, 
            "robot_news", 
            self.callback_robot_news, 
            10
        )
        self.get_logger().info("Smartphone is ready to receive news.")

    def callback_robot_news(self, msg):
        # This function runs every time a message arrives
        self.get_logger().info("I received: " + msg.data)

def main(args=None):
    rclpy.init(args=args)
    node = SmartphoneNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Step 3: Run It
You need two terminals.
*   Terminal 1: `ros2 run my_robot_controller publisher_node`
*   Terminal 2: `ros2 run my_robot_controller subscriber_node`

You will see the messages flowing from one to the other.

</Personalization>

<Personalization level="expert" language="english">

## DDS Tuning, QoS, and Zero-Copy Transport

**The Reality of Physical AI Communication**

For a chatbot, latency of 500ms is acceptable. For a bipedal humanoid, a latency of 50ms in the IMU (Inertial Measurement Unit) stream will cause the robot to fall over. The default ROS 2 behavior ("TCP-like" reliability) is often insufficient for Physical AI.

### 1. Quality of Service (QoS) Policies

ROS 2 allows you to tune the underlying DDS (Data Distribution Service) behavior using QoS policies.

*   **Reliability**:
    *   `RELIABLE`: Guarantees delivery. If a packet is lost, it retries. *Use case: Robot State commands (Sit, Stand).*
    *   `BEST_EFFORT` (UDP-like): Fire and forget. If a packet is lost, ignore it. *Use case: Sensor data (LiDAR/Camera).* If you miss frame #100, you don't want it re-sent when frame #105 is already available. Old data is dangerous data.

*   **Durability**:
    *   `VOLATILE`: New subscribers only hear messages sent *after* they join.
    *   `TRANSIENT_LOCAL`: The publisher saves the last few messages ("Latched"). When a new subscriber joins, they get the last message immediately. *Use case: Map data or Static Transforms.*

**Implementation Example:**

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

self.camera_pub = self.create_publisher(Image, "camera/raw", qos_profile)
```

### 2. The Bandwidth Problem & Zero-Copy

A 4K Image (RGBA) is approx 32MB uncompressed. At 60FPS, that is ~2GB/s.
If you have a pipeline: `Camera Driver -> Resize Node -> AI Inference Node -> Debug View`, you are copying that 32MB buffer 3 times in RAM. This will choke the memory bandwidth of the Jetson Orin.

**Zero-Copy (Intra-process Communication)**
If nodes are in the same process (Composition), ROS 2 can pass a pointer to the memory address instead of copying the data.
*   *Requirement:* You must use `UniquePtr` in C++ or ensure strict type handling in shared memory setups.
*   *Constraint:* This is difficult to achieve in Python due to how Python handles objects. For high-bandwidth video pipelines in this course, we will push students towards NVIDIA's **Isaac ROS** (NITROS), which uses GPU-direct shared memory to bypass the CPU entirely.

### 3. Topic Remapping
Never hardcode topic names like `/camera/image` in your logic.
Always use generic names like `image_raw`.
Why? Because your robot might have 4 cameras.
When you launch the node, you **Remap** the topic:

```bash
ros2 run vision_package object_detector --ros-args --remap image_raw:=/camera_front/left/image
```

### 4. Interface Definition (.msg files)
While `std_msgs/String` is easy, real robots use custom messages.
For a Humanoid Hand:
```text
# HandControl.msg
float32 thumb_angle
float32 index_angle
float32 force_newton
bool is_grasping
```
Using standard types (`sensor_msgs`) is preferred for interoperability, but custom messages are unavoidable for specific hardware control.

</Personalization>

<Personalization level="novice" language="urdu">

## Robot Ki Bol Chaal: Topics

**Broadcast Ki Misaal**

Pichlay sabaq mein hum ne **Nodes** banaye thay. Lekin agar "Dimagh" wala node "Haath" wale node ko hukum na de sakay, to robot bekaar hai.
ROS 2 mein baat karne ka sab se bara zariya **Topics** hain.

Topic ko ek **Radio Station** ya **YouTube Channel** samjhein.
*   **Publisher (Nashar karne wala)**: Yeh wo node hai jo bolta hai. Jaise Radio Jockey. Wo bas hawa mein baat phenk deta hai, usey nahi pata kaun sun raha hai.
*   **Subscriber (Sunne wala)**: Yeh wo node hai jo radio tune karta hai taake baat sun sakay.
*   **Topic**: Channel ka naam (maslan: `/robot/camera/tasveer`).

**Yeh Tareeqa Kyun?**
Sochiye agar Camera Node ko har doosre node ka phone number yaad rakhna parta. Agar aap robot par ek nayi screen lagatay, to Camera ka code badalna parta. Topics ke sath, Camera bas tasveer "Publish" kar deta hai. 1 banda sunay ya 100, Camera ko parwah nahi. Is se system flexible rehta hai.

### Mashq: Batuni Robot

Hum do nodes banayenge. Ek ginti giney ga (Publisher), aur doosra usey print karega (Subscriber).

#### Qadam 1: Publisher Node
Apne package mein `publisher_node.py` file banayein.

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String  # Message ki kism

class RobotNewsStation(Node):
    def __init__(self):
        super().__init__("robot_news_station")
        
        # Publisher banaya
        # Topic ka naam: "robot_news"
        # Queue Size: 10 (Agar sunne wala slow ho to 10 messages save rakho)
        self.publisher_ = self.create_publisher(String, "robot_news", 10)
        
        # Timer: Har 0.5 second baad function chalaye ga
        self.timer_ = self.create_timer(0.5, self.publish_news)
        self.get_logger().info("News Station On Hai!")

    def publish_news(self):
        msg = String()
        msg.data = "Salaam! Robot theek chal raha hai."
        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = RobotNewsStation()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Qadam 2: Subscriber Node
Ab `subscriber_node.py` banayein.

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SmartphoneNode(Node):
    def __init__(self):
        super().__init__("smartphone")
        
        # Subscriber banaya
        # Topic ka naam BILKUL wahi hona chahiye: "robot_news"
        self.subscriber_ = self.create_subscription(
            String, 
            "robot_news", 
            self.callback_robot_news, 
            10
        )
        self.get_logger().info("Smartphone khabar sunne ke liye tayar hai.");

    def callback_robot_news(self, msg):
        # Jab bhi naya message aaye ga, yeh function chalega
        self.get_logger().info("Maine suna: " + msg.data)

def main(args=None):
    rclpy.init(args=args)
    node = SmartphoneNode()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Qadam 3: Chalayein
Do alag terminals kholein.
*   Terminal 1: `ros2 run my_robot_controller publisher_node`
*   Terminal 2: `ros2 run my_robot_controller subscriber_node`

Aap dekhenge ke ek taraf se message ja raha hai aur doosri taraf aa raha hai.

</Personalization>

<Personalization level="expert" language="urdu">

## Topics Ki Gehrai: QoS Aur Bandwidth

**Haqeeqi Physical AI Ki Zarooriyat**

Chatbot ke liye agar jawab 500ms late ho jaye to khair hai. Lekin agar chalne wale robot (Humanoid) ka sensor data 50ms late ho jaye, to robot mun ke bal gir jayega. ROS 2 ka default behavior (jo TCP jaisa hota hai) aksar Physical AI ke liye kaafi nahi hota.

### 1. QoS (Quality of Service) Policies

Aap ROS 2 ke communication system (DDS) ko tune kar sakte hain.

*   **Reliability (Bhartosa)**:
    *   `RELIABLE`: Yaqeen dilata hai ke message pohnch gaya. Agar gum ho jaye, to dobara bhejta hai. *Kahan use karein? Robot ke ahem hukm ke liye (jaise: Baith jao).*
    *   `BEST_EFFORT`: Bhej diya aur bhool gaye. *Kahan use karein? Sensors (LiDAR/Camera) ke liye.* Agar frame #100 gum ho gaya, to humein frame #100 dobara nahi chahiye kyunke ab tak frame #105 aa chuka hai. Purana data robot ko confuse kar sakta hai.

*   **Durability**:
    *   `VOLATILE`: Naya subscriber sirf wohi sunega jo uske aane ke baad bola gaya.
    *   `TRANSIENT_LOCAL`: Publisher aakhri kuch messages save rakhta hai ("Latched"). Naye aane wale ko pichla message foran milta hai. *Yeh Maps (naqshay) share karne ke liye best hai.*

**Code Mein Istemal:**

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT, # Tez lekin risk wala
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

self.camera_pub = self.create_publisher(Image, "camera/raw", qos_profile)
```

### 2. Bandwidth Aur Zero-Copy

Ek 4K Tasveer taqreeban 32MB ki hoti hai. Agar aap 60FPS par chala rahe hain, to yeh 2GB per second data banta hai.
Agar aap data ko `Camera -> Resize -> AI -> Screen` bhejte hain, to RAM mein ye data 3 baar copy hoga. Is se Jetson computer slow ho jayega.

**Zero-Copy**
Agar nodes ek hi process mein hon, to ROS 2 data copy karne ke bajaye sirf memory address (pointer) pass karta hai.
Physical AI mein high-speed vision ke liye hum **NVIDIA NITROS** packages use karte hain jo CPU ko bypass kar ke seedha GPU memory use karte hain.

### 3. Topic Remapping
Apne code mein kabhi topic ka naam fix na likhein. Hamesha generic naam use karein (jaise `image_raw`).
Jab aap node chalate hain, to **Remapping** ke zariye topic ka naam badal dein:

```bash
ros2 run vision_package object_detector --ros-args --remap image_raw:=/camera_front/left/image
```

Is se aap ka code reuse karna aasaan ho jata hai, chahay robot mein 1 camera ho ya 10.

</Personalization>

<Quiz questions={[
  {
    question: "Which QoS setting is best for high-frequency sensor data like LiDAR?",
    options: ["Reliable", "Best Effort", "System Default", "Transient Local"],
    correctAnswer: 1
  },
  {
    question: "What is the role of a Subscriber node?",
    options: [
      "To send data to other nodes",
      "To listen for specific topics and process the data",
      "To manage the robot's battery",
      "To compile the code"
    ],
    correctAnswer: 1
  },
  {
    question: "Urdu: Agar aap chahte hain ke naye aane wale node ko purana map foran mil jaye, to kaunsi Durability setting use karenge?",
    options: [
      "Volatile",
      "Transient Local",
      "Best Effort",
      "Slow Local"
    ],
    correctAnswer: 1
  }
]} />